----------------------------------------------- cmd 창에서 수행한 작업들
-- 1. cmd창에서 db 관리하기

--sqlplus sys/java@localhost:1521 as sysdba

--cmd창에서 관리자계정(sys)으로 네트워크상 내 컴퓨터(localhost)에 접속
--java는 설정한 비밀번호. 포트 No는 1521(오라클). as sysdba는 관리자로서 로그인했다는 의미
--이를 실행하면 pc가 db server가 됨

--참고: conn sys /as sysdba
--SQL Commandline창에서 입력 후 패스워드 입력하면 접속됨. conn은 connect를 의미

-- 2. cmd창에서 사용자 생성
--create user test identified by java(pw);
--test는 사용자명 identified by java는 java라는 pw에 의해 식별하겠다는 의미.

-- 2-1 생성된 사용자 확인
select * from all_users; -- 모든 사용자 정보 출력

-- 2-2 사용자 생성과 함께 사용할 테이블스페이스 지정하기
--create user sjg identified by java (세미콜론x - 마지막 행 on tmp뒤에 들어가니까)
--default(기본으로 사용할) tablespace tmp(여기서 tmp는 테이블스페이스의 이름)
--quota(용량, 사용한도) unlimited(무제한: 테이블스페이스에 설정된 최대 용량까지) on tmp;

-- 3. cmd창에서 권한(세션) 부여
--grant connect, resource to test(유저명);
--connect: test에게 접속, 접속할 권한 부여
--resource: 기본적인 객체(table,trigger,index,cluster,sequence등)를 drop,alter,create
--그리고 컬럼을 insert,update,delete 할 수 있는 권한을 모아놓은 role
--권한(세션)이란? 놀이동산 입장권 팔찌같은 개념. 서버가 클라이언트에 부여함.

-- 4. cmd창에서 사용자 계정으로 로그인
--sqlplus test/java@localhost:1521
--관리자로서 로그인하는 것이 아니므로 as sysdba는 붙이지 않음
--권한이 부여되지 않았을 경우 세션 부족 에러발생. 3번에서 권한 부여하면 가능.

-- 5. cmd창에서 다른 사람의 oracle서버에 접속하기
-- cmd창에서 관리자 로그인-시작버튼에서 내 pc번호 확인-create user pc(번호) identified by java;
-- connect, resource 권한 부여
-- 접속할 곳의 IP주소 확인(cmd창에서 ipconfig 후 ipv4가 내 IP주소)
-- 접속할 PC 방화벽 해제(제어판-시스템 및 보안-windows방화벽-방화벽 해제)
-- 접속 sqlplus pc(번호)/java@(IP주소):1521
-- 이 때 위에서 본인 PC에 접속할 사람의 계정 생성/권한 부여가 완료되었다면, 다른 사람이 접속할 수 있음

-- 6. cmd창에서 테이블스페이스 만들기
--테이블스페이스란? 테이블(=파일, 릴레이션)이 관리하는 데이터가 들어간 것(*.dbf파일 형태)
--공간을 쓰기 위해 (위치)주소+명칭+사람(누가 쓸 것인가)이 필요하다.
--여기서 주소: c:\oraclexe... 명칭(테이블스페이스명) 사람: 계정명

--create tablespace tmp
--datafile 'C:\oraclexe\app\oracle\oradata\XE\tmp.dbf(테이블스페이스의 경로)' size 30M;
--물리적 위치를 지정하고('C:\oraclexe\app\oracle\oradata\XE\tmp.dbf')
--크기를 지정한다(size 30M).

----------------------------------------------- 기본 개념

--<데이터와 정보>
--데이터는? 현실 세계로부터 관찰이나 측정 등의 수단을 통해 수집한 사실이나 값(의미가 부여되지 않은)

--정보(Information)는? 특정 상황에 대한 의사결정을 내릴 수 있는 유용한 해석이나 데이터 상호 간의 관계
--데이터를 가공한 값(의미있는, 혹은 나에게 의미있게 만든)

--데이터를 가공하여 정보를 추출하는 과정(슬라이드 5p)
--자동차회사 고객정보 데이터베이스가 있다고 할 때, 판촉물을 무작정 모두에게 보낸다면 막대한 비효율 발생
--->이를 줄이기 위해 1차 정보화 과정: 연식으로 필터링(5년 이상) & 2차 정보화 과정: 지역으로 필터링(서울)
--이와 같은 정보화 과정을 통해 예산을 줄일 수 있고, 이는 의미있는 행위이다. 때문에 결과물을 정보라 부를 수 있다.

--메타데이터란(슬라이드 6p)? 데이터의 구조(Structure)나 제약사항(Constraints)과 같은
--속성(Properties)이나 특성을 기술하는 것.

--데이터(김길동, 이수근, 소나타, 2005년식, 서울시 등 눈에 보이는 데이터)에 대한 
--데이터(문자형, 숫자형 등 눈에 보이지 않는 데이터)


--<데이터베이스(Database, DB)>란?
--특정 조직 내에서 다수의 사용자들이 공유(share)할 수 있도록 통합(integrate)시키고 
--컴퓨터 저장 장치에 저장(store)시킨 운영(operation)데이터의 집합이다.

--데이터베이스의 특성
    --1. 실시간 접근(real-time accessibility)
    --언제든 사용할 수 있게 하는 것. 가용성. 수시적이고 비정형적인 질의(조회)에 대해 실시간
    --처리에 의한 응답이 가능해야 한다.
    --2. 계속적인 변화(continuous evolution)
    --db의 상태는 동적이다. 새로운 데이터의 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지한다
    --예) 좌석예매 시 자리가 갑자기 사라지는 것
    --3. 동시 공유(concurrent sharing)
    --db는 서로 다른 목적을 가진 여러 이용자들을 위한 것이므로 다수의 사용자가 동시에 같은 데이터를
    --이용할 수 있어야 한다.단 이는 제한이 생김. 누가 접근중일 때 타인을 막는 것
    --4. 내용에 의한 참조(content reference)
    --db에 있는 데이터를 참조할 때 레코드의 주소/위치에 의해서가 아니라
    --사용자가 요구하는 데이터 내용으로 데이터를 찾는다
    --내가 등록해 놓은 데이터 중 유사한 것을 제시하는 것
    --(예: 검색 사이트의 자동완성, 주소록 자동완성 등)

--<SQL> : Structed Query Language

--내가 어떤 사이트에 로그인하는 과정을 생각할 때,
--클라이언트(요청자)는 서버(응답자)에 로그인 요청(request)을 보낸다
--이때 서버는 클라이언트에 허용 또는 거부라는 응답(response)을 보낸다
--이 과정에서 클라이언트측의 요청 툴이 cmd, SQL commandline, SQL Developer 등이다

--파일 관리 시스템(슬라이드 12p)
--중복/불일치가 가장 심각한 문제 -> 해결을 위해 통합적으로 관리하는 데이터베이스 관리 시스템(dbms)을 도입하게 됨

--관계형 데이터베이스 모델(RDBMS)(슬라이드 24p)
--현재 가장 많이 사용되는 db모델. 자연어에 가까운 문법
--자연어란? 사람이 이해하기 쉬운 언어 - 때문에 배우기 쉽다
--데이터를 어떻게(HOW) 가져올 것인가 대신 어떤(WHAT) 데이터를 원하는지만 기술
--데이터 HOW? 몇발 걸어가서 문고리를 어떻게 돌리고....
--데이터 WHAT? 뭐 뭐 뭐 가져와라. 어떻게는 알아서 하고. - 사용자/개발자 입장에서 단순해짐
-- +명령어나 문법이 표준화되어 대부분의 명령어는 모든 RDBMS에서 사용 가능
--(슬라이드 25p) 대표적인 SQL
--영업부 : 조건 / SELECT 열방향 필터링 WHERE 행방향 필터링

--@@ 테이블 ,열, 행, 키, CONSTRAINT 이해하기
--교재29P 릴레이션(RELATION) = 테이블
--테이블: 2차원 배열
--Constraint: 한정(제약)하다. 오라클과의 약속.

--서로 비슷한 개념. 숙지 필요
--릴레이션       파일       테이블
--속성          필드        열, 컬럼
--튜플          레코드      행

--교재30p
--중복 튜플이 들어가는 것을 막기 위해 어떻게 해야 하는가?
--모든 속성별로 같은 값이 있나 모두 체크: '같은 값이 x개 이상이면 동일 인물이다'라는 규칙을 정했다면 체크 가능
--하지만 튜플이 천만개라면? 처리 속도 저하.

--교재 30p, 슬라이드 34p
--후보키와 기본키, 대체키, 복합키 개념
--이 중 후보키와 기본키는 NOT NULL, NO DUPLICATE
--후보키의 최소성: 컬럼을 붙이고 붙이면 더 유일해진다. 하지만 길어짐. 
--기본키역할을 할 컬럼이 있다면 그것만 쓰면 됨

--교재 32p
--자식 테이블의 외래키가 부모 테이블의 기본키를 참조한다.
--부모 테이블의 기본키가 자식 테이블의 외래키로 전이된다.

--(참고) 컬럼명은 명확하게 잡기
--전화번호면 그냥 전화번호라 하지 말고, 사원휴대전화번호, 사업장전화번호 등등
--단 너무 길어도 좋지 않음

--VARCHAR2는 테이블명의 기본값
--VARCHAR2(7)
--여기서 VARCHAR2는 자료형(데이터 타입), (7)은 크기(7byte라는 뜻)
--VAR:Variable(변수) CHAR:Character(문자)	=> 가변길이 문자형(채우고 남으면 반납함)
--varchar2(10 char) 이 때 char는 글자(알파벳/한글/일본어 죄다 10자)
--CHAR(7): 고정길이 문자형 (남아도 반납하지 않음)
--타입의 길이를 정할 때 한글은 1개당 3바이트

-- 고정길이, 가변길이의 차이
-- char(6) 'a'  where ?? = 'a     '	a에 공백5개를 정확히 넣어야 데이터가 찾아짐. 길이가 고정되어 있을 때 사용할 것
-- varchar2(6) 'a' where ?? = 'a'	공백까지 정확히 넣지 않아도 데이터가 찾아짐.


--NUMBER(5): 여기 5 는 자리수. 99999~-99999까지 커버 가능
--NUMBER(8,2): 소수점 자리 포함해서 8자리. 2는 소수부 56789.12
--DATE는 길이(또는 크기라 부름)가 없음

--null과 not null의 차이
--지하철 열차 출발과 문의 관계: 필수적인 관계 = mandatory = not null 무조건 닫혀야(있어야) 한다
--지하철 열차 출발과 안내방송의 관계: 선택의 관계 = optional = null 꼭 하지 않아도 출발한다
--회원가입 폼에서 별표(*): 필수(mandatory, not null)
--별표 없는 항목: 선택(optional, null)

--기본키는 반드시 Not Null이다. 하지만 외래키는 Null일 수 있다.

--<이상현상(anomaly)>
--원인은 설계 오류. 해결을 위해 정규화가 필요.
    --1. 삽입이상: 레코드를 넣으려 하는 데 이상한 현상이 발생하는 것.
    --예) PK인 수강과목코드가 없는 레코드를 추가하려고 할 때(수강 전 학생을 추가하려고 할 때) 발생하는 오류
    --2. 수정이상: 데이터 불일치. 동일한 데이터를 공유해서 쓰지 않고 분리되어 있을 때 주로 발생.
    --3. 삭제이상: 한 가지 속성만 삭제하려는데 레코드 전체가 삭제되는 현상.

--SQL(Structed Query Language. 구조화된 질의 언어)의 종류	<중요>
--1. DDL(Date Definition Language): 데이터 정의어(DB 구조 또는 스키마 정의)
    -- 1) CREATE(개체 생성)
    -- 2) ALTER(개체 변경)
    -- 3) DROP(개체 삭제)
--2. DML(Data Manipulation Language): 데이터 조작어
    -- 1) INSERT(데이터 입력)
    -- 2) UPDATE(데이터 수정)
    -- 3) DELETE(데이터 삭제)
    -- 4) SELECT(데이터 검색)
--3. DCL(Date Control Language): 데이터 제어어
    -- 1) GRANT(권한부여)
    -- 2) REVOKE(권한회수)
--4. TCL(Transaction Control Language): 트랜잭션 제어어
    -- 1) COMMIT(트랜잭션 적용)				커밋은 종료, 롤백은 처음으로 돌아간다. 커밋 수행 시 DBF파일에 저장됨
    -- 2) ROLLBACK(마지막 COMMIT시점으로 회귀)
    -- 3) SAVEPOINT(임시저장)

--트랜잭션의 정의와 특징(PPT 17p 책 중간 37p 40p도 참고)
--<트랜잭션> db를 수정(변경)하기 위해서 수행되어야 할 '논리적인 하나의 단위'. 여러개의 SQL로 구성되어 있다
--ATM에 카드 넣고 작동->네트워크를 타고 온 계좌 정보와 db에 있는 계좌 정보가 일치하는 지 확인
---> 맞다는 승인 -> 리턴 -> 인출금액 입력 -> 비밀번호 입력 -> 비밀번호가 맞는가 체크
--->잔액 업데이트->인출금액 내보내기
--이때, db잔액은 업데이트되고 금액이 나오기 전에 정전된다면?  처음으로 되돌아감(Nothing)

--<트랜잭션의 특징 4가지>		'원일고지'
    --1. 원자성: 잘 수행되면 All, 중간에 조금이라도 문제가 생기면 처음으로 돌아간다.
    --전혀 이루어지지 않은 것과 같다(Nothing) - All or Nothing (여기서 All은 commit개념과 유사)
    --2. 일관성: 트랜잭션간 영향은 한 방향으로만 전달된다(ATM순서는 언제나 동일하다)
    --3. 고립성: 화장실 같은 것. 하나의 트랜잭션이 실행을 선점하면 다른 것은 침범할 수 없고 수정/삭제도 할 수 없다.
    --4. 지속성: 커밋 이후에(정상적으로 수행된 경우) 영구적으로 그대로 남는다

----------------------------------------------- DB 설계 및 구현
--1. 요구사항 분석(슬라이드 87p 책50p)
--조사범위 결정-요구사항 수집-요구사항 검토/승인

--요구사항 분석 과정에서 개체 찾기
--문장에서 명사를 찾는다-명사들 중 범위를 한정할 수 있는 것을 추린다

    --요구사항 분석 시 끄집어내야 할 세 가지
    --1) 개체(Entity): 학생, 교사, 수업과목 등 현실세계에서 명사로 이루어진 것들. (객체와는 다르다)
    --개체별 구성 요소는 2개 이상으로 이루어져 있음. 
    --계속 관심을 갖고 업데이트해야 함. 현실 세계를 대표하는 중요한 개념. 
    --서로 구별 가능. 범위가 명확. (http://www.dbguide.net/db.db?cmd=view&boardUid=12843&boardConfigUid=9&categoryUid=216&boardIdx=31&boardStep=1 참조)
    
    --2) 관계(Relationship): 개체와 개체간의 연관성
    --(예: 학생과 교사의 관계-가르치고 가르침을 받는다(교육)-교육이라는 관계가 있음).
    --주로 동사로 이루어져 있음. (과목과 학생은? 학생은 과목을 수강하고 과목은 학생에 의해 수강된다)
    
    --3) 속성(Attribute): 개체가 공통적으로 갖고 있는 성질. 
    --개체 집합=구성원=인스턴스(여기에서 인스턴스는 개체를 구성하는 하나 하나의 요소임)
    --(학생 개체라면 이름, 나이, 키, 성별 등 과목 개체라면 과목명, 시수, 담당교사)

--2. 데이터 모델링(설계) 단계(슬라이드 92p 책 52p)
    --1) 개념설계: 개체, 관계를 잡아내는 것. ERD작성
    --ERD?(Entity Relationship Diagram: 개체와 관계를 그린 그림)
        
    --2) 논리설계: 속성을 찾아내고 식별자를 정하고 정규화와 같은 상세화 과정 수행
    --보통 논리설계까지 끝나면 설계가 끝났다고 봄
    --식별자란? 유니크한(NULL값이 없는). ERD에서 밑줄을 그어 구분
    
    --3) 물리설계: 스키마(데이터 구조)를 일정한 기준과 규칙에 의해 도출.
    --칼럼의 데이터 타입과 크기 결정(문자냐? 몇바이트냐?)
    
    --(참고)왜 다대다 관계를 DB에서 처리할 수 없는가?(교재 53P)
    --한 사원이 여러 사업장을 돌아다닐 수 있고, 사업장 하나에 여러 사원이 근무할 수 있다. - 다대다 관계
    --데이터 중복 등의 문제가 발생 -> 이 때 근무라는 관계를 이용.
    --시간 개념 때문에 다대다 관계가 발생했으므로, 근무 관계에 투입일이라는 속성을 추가
    --->사원번호와 사업장번호가 중복된다 해도 투입일이 다르므로 올바른 데이터 + 사원번호와 사업장번호를 합치면 역시 중복은 해소됨
    --이는 중간 관계를 개체화(해소)한 과정.
    --이 때의 개체-관계를 액션 엔티티, 교차 엔티티라고 부름       @@이해가 잘? @@
    
--3. 테이블 설계
--ERD 제작 순서: 용어사전/단어사전/자료사전 -> 테이블 명세서 -> ERD만들기

--4. ER-win을 이용한 모델링
--ERD작성 시 개체는 네모, 속성은 동그라미, 관계는 마름모로 나타냄
    --ERD에는 외래키를 쓰지 않는다. 하지만 전이된 기본키는 존재한다.
    
    --ERwin에서 Logical: 논리설계 Physical: 물리설계
    --메뉴-Model-Model properties-Notation(표기법)에서 IE로 수정
    --물리설계로 전환하면 Database메뉴가 새로 생김
    --처음에 format-table display-column datatype에 체크하면 화면에 데이터타입을 함께 띄워줌
    --ERwin에서 ERD 만들고 체크포인트
        --1. VARCHAR2가 4000byte를 초과했는가? 넘으면 안 됨. VARCHAR2 최대 크기가 4000byte임
        --2. NUMBER가 38자를 넘었는가? 넘으면 안 됨
        --3. VARCHAR2가 ()괄호만 있는 경우. 괄호만 있으면 안 됨(+괄호가 없는 경우->없으면 안 됨)
            --단 number는 ()괄호만 있을 수 있다
        --4. 기본키 외래키의 자료형과 크기가 서로 동일해야 함
        --5. DATE에는 괄호가 없어야 한다
        
--5. 한국건설의 물리적 DB모델링

--6. DB 스키마 생성
-- forward과정(ERD -> forward -> 오라클DB)
    --ERwin 메뉴-tools-forward engineer-schema generation에서 trigger의 체크 다 해제한 후
    --Generate 클릭-오류가 뜬다면 입력이 올바른지 다시 확인.
    --'..already used by an existing object' 는 이미 있다는 뜻이므로 컨티뉴해서 잘 되면 OK
    --SQL 디벨로퍼에서 새로고침해서 잘 뜨면 성공

-- reverse과정(오라클DB -> reverse -> ERD)
    -- ERwin에서 new model생성(논리/물리) -> physical클릭->db메뉴의db connection클릭
    -- ->pw누르고 커넥트->tools메뉴의 reverse engineer->logical/physical선택하고
    -- currnet user->pw누르코 커넥트->db스키마가 erwin으로 들어옴
----------------------------------------------- 기타

--SQL구문
--ppt 134p 책 중간 10p
--CREATE TABLE(db오브젝트 생성하기)

--SQL 디벨로퍼에서 새로 만들기/db접속
    --접속이름/사용자이름/pw는 생성해 둔 사용자명/비밀번호로 입력
    --테스트 누르고 상태에 성공 뜨면 접속
--실행하기(Ctrl+Enter)
    --단 이때 실행할 해당 부분에 클릭하고 실행할 것
--변경사항 커밋: 화면좌측에서 테이블 클릭-데이터 변경-변경사항 커밋 버튼 누르기
--대소문자 변경: 블럭잡고 Alt + '
--행 번호 토글: 번호 나올 여백에서 마우스 우클릭하고 토글 선택
--삭제시 선택창의 계단식: cascade(자식테이블도 함께 사라진다) / 비우기는 싹 지우겠다
--주석 색상 바꾸기 도구-환경설정-코드편집기-pl/sql구문 색상-스타일에서 
    --기본 주석 선택-적당히 바꾸기
--변경된 사항이 좌측 창에 잘 반영되지 않는다면 새로고침부터 해 보기

--ERwin에서 buyer테이블을 추가할 때, 여기서 추가했다고 db에서도 같이 추가된 것은 아님.
--ERwin에서 추가한 부분을 db로 보낼 수도 없음(buyer가 이미 있으므로 forward 엔지니어링이 거절됨). 즉 추가 불가.
--forward 엔지니어링은 create하는 것이기 때문(없던 것만 추가 가능. 아니면 테이블에서 삭제하고 다시 하거나)
--ERwin에서 추가한 부분을 db에 추가하려면? ALTER로 따로 넣어줘야 함.

--DDL문(CREATE, ALTER, DROP, RENAME, TRUNCATE)을 사용할 때는 자동 커밋됨
--만약 DDL문에서 오류가 나더라도 자동 커밋됨
--결론: DDL문 사용 시 각별히 주의할 필요가 있음

--카디널리티(cardinality): 행의 개수를 부르는 말
--디그리(degree): 차수(열의 개수)

--관계대수: 기호
--시그마-가로방향(행) 필터링-WHERE
--특정 테이블로부터(=SELECT * FROM 테이블명)
--(시그마 LPROD_ID>5라면? 해당하는 데이터만 가져와라)
--파이-세로방향(열) 필터링-SELECT
--(시그마, 파이는 나중에 생각해도 무방)

--기본키와 UNIQUE(유일)의 차이점: 기본키는 NULL불가, UNIQUE는 NULL가능

--n분 전 시점으로 돌아가기(커밋/드랍 이전으로 되돌리려고 할 때) - flashback 검색
--flashback table MEMBER to timestamp sysdate 1/24/60*10;
--alter table MEMBER enable row movement;





--빠진 부분
--ERD제작 순서