package f_OOP2;

public class OOP2_Basic {
	public static void main(String[] args) {
		/*
		1. 상속 (~은 ~이다) : is a				drawshape의 frame
		  - 기존 클래스를 재사용하여 새로운 클래스를 작성한다.
		  - 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		  - 새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 써주기만 하면 된다.
		  
		  class Parent{}	부모 클래스 없이는 자식 클래스가 존재할 수 없다.
		  class Child extends Parent{} 
		  - 상속해주는 클래스를 '조상클래스', 상속받는 클래스를 '자손클래스'라 한다.
		    : 조상클래스 - 부모클래스, 상위클래스, 기반클래스
		    : 자손클래스 - 자식클래스, 하위클래스, 파생된클래스
		    
		  - 멤버만 상속된다.
		  - 자손클래스의 멤버 갯수는 조상클래스보다 항상 같거나 많다.
		  
		2. 포함 (~은 ~을 포함하고 있다) : has a		drawshape의 circle, triangle
		  - 상속 이외에 클래스를 재사용하는 또다른 방법
		  - 한 클래스의 멤버변수로 다른 클래스를 선언하는 방법이다.
		  
		3. toString()
		  - 인스턴스의 문자열을 반환할 목적으로 정의
		  - 참조변수를 출력하면 참조변수가 가르키고 있는 인스턴스의 toString()을 호출한다.
		  - System.out.println(c); => System.out.println(c.toString());		이러면 생략된 toString()이 주소를 반환해줌
		  
		4. 단일상속
		  - 자바에서는 단일상속만 가능하다.
			  class TVCR extends TV,VCR{ // 표현 불가
			  
			  }
			  
		  - TV와 VCR에 동일명의 method가 있다면 어떤 것을 상속받을지 알 수 없다.
			VCR의 method명을 바꾼다면 그동안 VCR의 method를 사용하던 부분들을 모두 수정해야 한다.
		  - 클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다.
		  
		5. Object클래스(모든 클래스의 조상)
		  - 모든 클래스의 상속계층도 맨 위에 위치하는 조상 클래스이다.
		  - 다른 클래스로부터 상속받지 않는 클래스는 자동으로 Object클래스를 상속받는다.
			class Tv{
			
			}
			
			컴파일 후
			class Tv extends Object{
				Tv(){
					super(); 생성자 내부에서 부모 생성자를 호출할 때 사용. 모든 생성자 안쪽 첫줄에 들어감(맨 먼저 호출). this()와 한 생성자 안에서 같이 존재할 수 없다. 둘 중 하나만 존재한다. 없으면 자동 생성됨.
					
				}
			}
		  - 모든 클래스들은 Object클래스를 상속받는다.
		  - toString(), equals()와 같은 메서드를 따로 정의하지 않고 사용한 것은 Object클래스에 정의된 것이기 때문이다.
		  
		6. 오버라이딩(override)
		  - 조상 클래스로부터 상속받은 "메서드의 내용을 재정의"하는 것.
		  - 오버라이딩을 위한 조건 (선언부는 동일해야 한다)
		    : 오버라이딩하는 조상 클래스의 메서드와
			      메서드명이 같아야 한다.
			      매개변수의 개수가 같아야 한다.
			      매개변수의 타입이 같아야 한다.
			      리턴타입이 같아야 한다.(오버로딩과의 차이점)
		  - 조상 클래스의 메서드를 자손클래스에서 오버라이딩할 때 접근제어자를 조상 클래스의 메서드보다 좁은 범위로 설정할 수 없다.
		  - 예외는 조상클래스의 메서드보다 많이 선언할 수 없다.
		  - 인스턴스멤버를 클래스멤버로 또는 그 반대로 변경할 수 없다.
		  
		7. super.
		  - 조상 클래스의 멤버와 자손 클래스의 멤버가 중복정의되어 있을 때 서로 구별하기 위한 용도로 사용
		  - 조상멤버와 자신의 멤버를 구분하는 데 사용한다는 점을 제외하고는 this와 근본적으로 같다.
		
		8. super() - 자식클래스의 생성자에서 부모클래스의 생성자를 호출할 때 사용
		  - this()와 마찬가지로 super()역시 생성자 호출이다.
		  - this()는 같은 클래스의 다른 생성자를 호출
		    super()는 부모클래스의 생성자를 호출
		  - 생성자의 첫 줄에는 super()를 호출해야 한다.
		  
		9. 제어자
		  - 클래스, 메서드, 변수의 선언부에 사용된다.
		  - 접근제어자와 그외 제어자
		  - 접근제어자 : private, default, protected, public
		      그외 제어자 : static, final, abstract, ....
		  - 접근제어자를 제일 왼쪽에 많이 둔다(필수는 아님).
		  - static(클래스의, 공통적인)
		    : 클래스변수, 클래스메서드, 클래스초기화블럭
		    : 클래스변수
		      - 인스턴스에서 공통적으로 사용
		      - 클래스명.변수명 => 인스턴스 생성 없이 호출
		      - 클래스가 method Area에 로드될 때 생성
		      
		  - final(마지막의, 변경할 수 없는)
		    : 변수에 사용 시 변경할 수 없는 상수가 된다.
		    : 메서드에 사용 시 오버라이딩할 수 없는 메서드가 된다.
		    : 클래스에 사용 시 상속할 수 없는 클래스가 된다(=다른 클래스의 조상이 될 수 없다).
		    
		  - abstract(추상의, 미완성의)
		    : 클래스에 사용시 추상클래스가 된다 => 추상메서드를 포함하고 있는 클래스
		    : 메서드에 사용시 추상메서드가 된다 => 구현부가 없는 메서드 		void method();
		    
		10. 접근제어자
		  - private : 같은 클래스에서만 접근가능
		  - default : 같은 패키지내에서만 접근가능
		  - protected : 같은 패키지 + 다른 패키지의 자손 클래스(상속이 안돼있으면 붙일 수 없다)
		  - public : 접근제한이 없다
		  - 클래스에는 public과 default만 사용가능
		  - 메서드와 변수에는 모두 사용가능
		  
		11. 캡슐화
		  - 접근제어자를 사용하는 이유
		    : 외부로부터 데이터를 보호하기 위해
		    : 외부에는 불필요한, (클래스 내에서)내부적으로만 사용되는 부분을 감추기 위해
		 */
		
		
		
		
		
		
	}
}
